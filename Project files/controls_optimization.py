# -*- coding: utf-8 -*-
"""Controls_optimization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uNelmHE3UDplRLZh7y866tIUOhMWPy2F
"""

import numpy as np
from scipy.integrate import solve_ivp
from scipy.optimize import minimize
import matplotlib.pyplot as plt

# Define the QRBS function
def QRBS(t, x, alpha, q_values, k_values):
    m = 486e-3
    d = 25e-2
    ob = x[12] - x[13] + x[14] - x[15]
    beta0 = 189.63
    beta1 = 6.0612
    beta2 = 0.0122
    b = 280.19
    g = 9.8
    Ix = 3.8278e-3
    Iy = 3.8288e-3
    Iz = 7.6566e-3
    Kfax = 5.567e-4
    Kfay = 5.567e-4
    Kfaz = 6.354e-4
    Kftx = 5.567e-4
    Kfty = 5.567e-4
    Kftz = 6.354e-4
    Jr = 2.8385e-5

    a1 = (Iy - Iz) / Ix
    a2 = -Kfax / Ix
    a3 = -Jr / Ix
    a4 = (Iz - Ix) / Iy
    a5 = -Kfay / Iy
    a6 = Jr / Iy
    a7 = (Ix - Iy) / Iz
    a8 = -Kfaz / Iz
    a9 = -Kftx / m
    a10 = -Kfty / m
    a11 = -Kftz / m
    b1 = d / Ix
    b2 = d / Iy
    b3 = 1 / Iz

    xd = [np.sin(t), np.cos(t), np.cos(t), -np.sin(t), 0.1 * t, 0.1, np.sin(t), np.cos(t), np.cos(t), -np.sin(t), 0.1 * t, 0.1]
    z = np.zeros(12)
    xdd = [np.cos(t), -np.sin(t), -np.sin(t), -np.cos(t), 0.1, 0, np.cos(t), -np.sin(t), -np.sin(t), -np.cos(t), 0.1, 0]

    for w in range(0, 11, 2):
        z[w] = xd[w] - x[w]

    for q in range(1, 12, 2):
        z[q] = x[q] - xdd[q-1] - alpha[q//2] * z[q-1]

    q1, q2, q3, q4, q5, q6 = 0.02, 0.02, 0.02, 0.02, 0.02, 0.02
    k1, k2, k3, k4, k5, k6 = 0.02, 0.02, 0.02, 0.02, 0.02, 0.02

    V1 = z[0]**2 / 2
    V3 = z[2]**2 / 2
    V2 = (V1 + z[1]**2) / 2
    V4 = (V3 + z[3]**2) / 2

    U2 = 1 / b1 * (-q1 * np.sign(z[1]) - k1 * z[1] - a1 * x[3] * x[5] - a2 * x[1]**2 - a3 * ob * x[3] + xdd[1] + (xd[1] - x[1]))
    U3 = 1 / b2 * (-q2 * np.sign(z[3]) - k2 * z[3] - a4 * x[1] * x[5] - a5 * x[3]**2 - a6 * ob * x[1] + xdd[3] + (xd[3] - x[3]))
    U4 = 1 / b3 * (-q3 * np.sign(z[5]) - k3 * z[5] - a7 * x[1] * x[5] - a8 * x[5]**2 + xdd[5] + (xd[5] - x[5]))

    U1 = m / (np.cos(x[0]) * np.cos(x[2])) * (-q6 * np.sign(z[11]) - k6 * z[11] - a11 * x[11] + xdd[11] + (xd[11] - x[11]) + g)

    if U1 == 0:
        Ux, Uy = 0, 0
    else:
        Ux = m / U1 * (-q4 * np.sign(z[7]) - k4 * z[7] - a9 * x[7] + xdd[7] + (xd[7] - x[7]))
        Uy = m / U1 * (-q5 * np.sign(z[9]) - k5 * z[9] - a10 * x[9] + xdd[9] + (xd[9] - x[9]))

    dx1 = x[1]
    dx2 = a1 * x[3] * x[5] + a2 * (x[1]**2) + a3 * ob * x[3] + b1 * U2
    dx3 = x[3]
    dx4 = a4 * x[1] * x[5] + a5 * (x[3]**2) + a6 * ob * x[1] + b2 * U3
    dx5 = x[5]
    dx6 = a7 * x[1] * x[3] + a8 * (x[5]**2) + b3 * U4
    dx7 = x[7]
    dx8 = a9 * x[7] + (Ux * (U1 / m))
    dx9 = x[9]
    dx10 = a10 * x[9] + (Uy * (U1 / m))
    dx11 = x[11]
    dx12 = a11 * x[11] + ((np.cos(x[0]) * np.cos(x[2]) * U1) / m) - g
    dx13 = b * V1 - beta0 - beta1 * x[12] - beta2 * (x[12]**2)
    dx14 = b * V2 - beta0 - beta1 * x[13] - beta2 * (x[13]**2)
    dx15 = b * V1 - beta0 - beta1 * x[14] - beta2 * (x[14]**2)
    dx16 = b * V1 - beta0 - beta1 * x[15] - beta2 * (x[15]**2)

    return [dx1, dx2, dx3, dx4, dx5, dx6, dx7, dx8, dx9, dx10, dx11, dx12, dx13, dx14, dx15, dx16]

# Define the objective function to minimize (tracking error)
def objective(params):
    alpha = np.full(6, params[0])
    q_values = np.full(6, params[1])
    k_values = np.full(6, params[2])

    # Call the ODE solver with current parameters
    sol = solve_ivp(QRBS, [0, 15], np.zeros(16), args=(alpha, q_values, k_values), method='RK45', t_eval=np.linspace(0, 15, 100))

    # Extract the solution
    t = sol.t
    x = sol.y.T

    # Compute the yaw error
    yaw_desired = 0.1 * t
    yaw_obtained = x[:, 11]
    yaw_error = np.sum((yaw_desired - yaw_obtained) ** 2)

    return yaw_error

# Initial guess for parameters
initial_params = [0.1, 0.1, 0.1]

# Minimize the objective function
result = minimize(objective, initial_params, bounds=[(0, 1), (0, 1), (0, 1)])

# Extract the best parameters and corresponding error
best_params = result.x
best_error = result.fun

print('Best Parameters:', best_params)
print('Best Error:', best_error)

# Plot the results for visualization if needed
# Plot the results for visualization if needed
alpha = np.full(6, best_params[0])
q_values = np.full(6, best_params[1])
k_values = np.full(6, best_params[2])

sol = solve_ivp(QRBS, [0, 15], np.zeros(16), args=(alpha, q_values, k_values), method='RK45', t_eval=np.linspace(0, 15, 100))

t = sol.t
x = sol.y.T

